<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Spark Catalyst Optimizer and spark Expression basics - Shivamani Patil</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Table of contents  Overview Trees Rules Expression CodegenFallback Example of spark native function using Unary expression  Spark Catalyst Overview  Core of Spark dataframe API and SQL queries. Supports cost based and rule based optimization. Built to be extensible :  Adding new optimization techniques and features Extending the optimizier for custom use cases   At core it uses trees On top of it various libraries are written for query processing, optimization and execution."><meta property="og:image" content><meta property="og:title" content="Spark Catalyst Optimizer and spark Expression basics"><meta property="og:description" content="Table of contents  Overview Trees Rules Expression CodegenFallback Example of spark native function using Unary expression  Spark Catalyst Overview  Core of Spark dataframe API and SQL queries. Supports cost based and rule based optimization. Built to be extensible :  Adding new optimization techniques and features Extending the optimizier for custom use cases   At core it uses trees On top of it various libraries are written for query processing, optimization and execution."><meta property="og:type" content="article"><meta property="og:url" content="https://shivamanipatil.github.io/posts/spark-catalyst/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-23T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-23T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spark Catalyst Optimizer and spark Expression basics"><meta name=twitter:description content="Table of contents  Overview Trees Rules Expression CodegenFallback Example of spark native function using Unary expression  Spark Catalyst Overview  Core of Spark dataframe API and SQL queries. Supports cost based and rule based optimization. Built to be extensible :  Adding new optimization techniques and features Extending the optimizier for custom use cases   At core it uses trees On top of it various libraries are written for query processing, optimization and execution."><script src=https://shivamanipatil.github.io/js/feather.min.js></script>
<link href=https://shivamanipatil.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://shivamanipatil.github.io/css/main.2f9b5946627215dc1ae7fa5f82bfc9cfcab000329136befeea5733f21e77d68f.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://shivamanipatil.github.io/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css media="(prefers-color-scheme: dark)"><script async src="https://www.googletagmanager.com/gtag/js?id=G-44FM66QXX5"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-44FM66QXX5")</script></head><body><div class=content><header><div class=main><a href=https://shivamanipatil.github.io/>Shivamani Patil</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/open-source>Open Source</a>
<a href=/about>About</a></nav></header><main><article><div class=title><h1 class=title>Spark Catalyst Optimizer and spark Expression basics</h1><div class=meta>Posted on Feb 23, 2022</div></div><section class=body><h2 id=table-of-contents>Table of contents</h2><ol><li>Overview</li><li>Trees</li><li>Rules</li><li>Expression</li><li>CodegenFallback</li><li>Example of spark native function using Unary expression</li></ol><h2 id=spark-catalyst-overview>Spark Catalyst Overview</h2><ul><li>Core of Spark dataframe API and SQL queries.</li><li>Supports cost based and rule based optimization.</li><li>Built to be extensible :<ul><li>Adding new optimization techniques and features</li><li>Extending the optimizier for custom use cases</li></ul></li><li>At core it uses trees</li><li>On top of it various libraries are written for query processing, optimization and execution.</li></ul><h2 id=trees>Trees</h2><ul><li>Trees in Catalyst consists of node objects.</li><li>Node - type and zero/more children</li><li>E.g If Literal(v: Int), Attribute(name: String), Add(l: TreeNode, r: TreeNode) are simple node types then x+(2+5) can be represented as Add(Attribute(x), Add(Literal(2), Literal(5))).</li></ul><p><img src=/catalyst-tree.png alt="Expression Tree"></p><h2 id=rules>Rules</h2><ul><li>Function from a tree to another tree i.e modifying the tree.</li><li>Replacing a pattern matched subtree with transformation. e.g Add(Literal(2), Literal(5)) => Literal(7)</li><li>Transform method provided with catalyst tree
e.g Recursively updates substructures to combine Literals</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Scala data-lang=Scala><span style=display:flex><span>tree<span style=color:#f92672>.</span>transform <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Add</span><span style=color:#f92672>(</span><span style=color:#a6e22e>Literal</span><span style=color:#f92672>(</span>c1<span style=color:#f92672>),</span> <span style=color:#a6e22e>Literal</span><span style=color:#f92672>(</span>c2<span style=color:#f92672>))</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>Literal</span><span style=color:#f92672>(</span>c1<span style=color:#f92672>+</span>c2<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>So</span><span style=color:#f92672>,</span> x <span style=color:#f92672>+</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>5</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>
</span></span></code></pre></div><h2 id=expression>Expression</h2><ul><li>Executable node in catalyst tree. Take inputs and evaluates them.</li><li>Can generate java source from which can be used for evaluation (docodegen()).</li><li>Should be deterministic. Like pure functions.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Scala data-lang=Scala><span style=display:flex><span>scala<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>import</span> org.apache.spark.sql.catalyst.expressions.Expression
</span></span><span style=display:flex><span>scala<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>import</span> org.apache.spark.sql.catalyst.expressions.<span style=color:#f92672>{</span><span style=color:#a6e22e>Literal</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>Add</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Expression and eval
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>scala<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>val</span> e <span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>Literal</span><span style=color:#f92672>(</span><span style=color:#960050;background-color:#1e0010>3</span><span style=color:#f92672>),</span> <span style=color:#66d9ef>Literal</span><span style=color:#f92672>(</span><span style=color:#960050;background-color:#1e0010>4</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>scala<span style=color:#f92672>&gt;</span> e<span style=color:#f92672>.</span>eval<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>res0<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Any</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Deterministic?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>scala<span style=color:#f92672>&gt;</span> e<span style=color:#f92672>.</span>deterministic
</span></span><span style=display:flex><span>res1<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><table><thead><tr><th>Type of Expression</th><th>Kind</th><th>Use</th></tr></thead><tbody><tr><td>BinaryExpression</td><td>Abstract class</td><td>2 children</td></tr><tr><td>CodegenFallback</td><td>trait</td><td>Interpreted mode, no code generation</td></tr><tr><td>UnaryExpression</td><td>Abstract Class</td><td>1 child</td></tr><tr><td>LeafExpression</td><td>abstract class</td><td>No children</td></tr><tr><td>Unevaluable</td><td>trait</td><td>Cannot be evaluated to produce a value (neither in interpreted nor code-generated expression evaluations), e.g AggregateExpression</td></tr></tbody></table><ul><li>Expression contract :</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Scala data-lang=Scala><span style=display:flex><span><span style=color:#66d9ef>package</span> org.apache.spark.sql.catalyst.expressions
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// only required methods that have no implementation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>def</span> dataType<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>DataType</span> <span style=color:#75715e>// Data type of the result of evaluating an expression
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span> <span style=color:#a6e22e>The</span> default behavior is to call the eval method of the expression<span style=color:#f92672>.</span> <span style=color:#a6e22e>Concrete</span> expression
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span> implementations should <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>this</span> to <span style=color:#66d9ef>do</span> actual code generation<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> doGenCode<span style=color:#f92672>(</span>ctx<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>CodegenContext</span><span style=color:#f92672>,</span> ev<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExprCode</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExprCode</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span> <span style=color:#a6e22e>Interpreted</span> <span style=color:#f92672>(</span>non<span style=color:#f92672>-</span>code<span style=color:#f92672>-</span>generated<span style=color:#f92672>)</span> expression evaluation
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span> <span style=color:#a6e22e>Slower</span> than generated code<span style=color:#f92672>(</span>&#39;relative<span style=color:#f92672>?</span><span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> eval<span style=color:#f92672>(</span>input<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>InternalRow</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>EmptyRow</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Any</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> nullable<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=codegenfallback>CodegenFallback</h2><ul><li>Trait derived from Expression which allows expressions to not support java code generation and go full interpreted mode.</li><li>e.g</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Scala data-lang=Scala><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>NoCodegenExp</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>UnaryExpression</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>CodegenFallback</span> <span style=color:#f92672>{}</span>
</span></span></code></pre></div><h2 id=example-of-spark-native-function-using-unary-expression>Example of spark native function using Unary expression</h2><ul><li>Here we will write a native function using Codegen and CodegenFallback.</li><li>Codegen example :</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Scala data-lang=Scala><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.sql.catalyst.expressions.<span style=color:#f92672>{</span><span style=color:#a6e22e>Expression</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>ImplicitCastInputTypes</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>UnaryExpression</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.sql.catalyst.util.DateTimeUtils
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.sql.types.<span style=color:#f92672>{</span><span style=color:#a6e22e>DataType</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>DateType</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.unsafe.types.UTF8String
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.sql.catalyst.expressions.codegen.<span style=color:#f92672>{</span><span style=color:#a6e22e>CodegenContext</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>ExprCode</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Returns beginning of month date for a date
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BeginningOfMonth</span><span style=color:#f92672>(</span>startDate<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>UnaryExpression</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>ImplicitCastInputTypes</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> child<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span> <span style=color:#f92672>=</span> startDate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> inputTypes<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Seq</span><span style=color:#f92672>[</span><span style=color:#66d9ef>DataType</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Seq</span><span style=color:#f92672>(</span><span style=color:#a6e22e>DateType</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> dataType<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>DataType</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>DateType</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// .eval calls nullSafeEval if input is non-null else it returns null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> nullSafeEval<span style=color:#f92672>(</span>date<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Any</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Any</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> level <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>DateTimeUtils</span><span style=color:#f92672>.</span>parseTruncLevel<span style=color:#f92672>(</span><span style=color:#a6e22e>UTF8String</span><span style=color:#f92672>.</span>fromString<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MONTH&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DateTimeUtils</span><span style=color:#f92672>.</span>truncDate<span style=color:#f92672>(</span>date<span style=color:#f92672>.</span>asInstanceOf<span style=color:#f92672>[</span><span style=color:#66d9ef>Int</span><span style=color:#f92672>],</span> level<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>def</span> doGenCode<span style=color:#f92672>(</span>ctx<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>CodegenContext</span><span style=color:#f92672>,</span> ev<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExprCode</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExprCode</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> level <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>DateTimeUtils</span><span style=color:#f92672>.</span>parseTruncLevel<span style=color:#f92672>(</span><span style=color:#a6e22e>UTF8String</span><span style=color:#f92672>.</span>fromString<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MONTH&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> dtu   <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>DateTimeUtils</span><span style=color:#f92672>.</span>getClass<span style=color:#f92672>.</span>getName<span style=color:#f92672>.</span>stripSuffix<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;$&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    defineCodeGen<span style=color:#f92672>(</span>ctx<span style=color:#f92672>,</span> ev<span style=color:#f92672>,</span> sd <span style=color:#66d9ef>=&gt;</span> <span style=color:#e6db74>s&#34;</span><span style=color:#e6db74>$dtu</span><span style=color:#e6db74>.parseTruncLevel(</span><span style=color:#e6db74>$sd</span><span style=color:#e6db74>, </span><span style=color:#e6db74>$level</span><span style=color:#e6db74>)&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> prettyName<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;beginning_of_month&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>CodegenFallback example :</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Scala data-lang=Scala><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.sql.catalyst.expressions.<span style=color:#f92672>{</span><span style=color:#a6e22e>Expression</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>ImplicitCastInputTypes</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>UnaryExpression</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.sql.catalyst.util.DateTimeUtils
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.sql.types.<span style=color:#f92672>{</span><span style=color:#a6e22e>DataType</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>DateType</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.unsafe.types.UTF8String
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> org.apache.spark.sql.catalyst.expressions.codegen.<span style=color:#f92672>{</span><span style=color:#a6e22e>CodegenContext</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>ExprCode</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Returns beginning of month date for a date
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BeginningOfMonth</span><span style=color:#f92672>(</span>startDate<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>UnaryExpression</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>ImplicitCastInputTypes</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>CodegenFallback</span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> child<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Expression</span> <span style=color:#f92672>=</span> startDate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> inputTypes<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Seq</span><span style=color:#f92672>[</span><span style=color:#66d9ef>DataType</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Seq</span><span style=color:#f92672>(</span><span style=color:#a6e22e>DateType</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> dataType<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>DataType</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>DateType</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// .eval calls nullSafeEval if input is non-null else it returns null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> nullSafeEval<span style=color:#f92672>(</span>date<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Any</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Any</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> level <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>DateTimeUtils</span><span style=color:#f92672>.</span>parseTruncLevel<span style=color:#f92672>(</span><span style=color:#a6e22e>UTF8String</span><span style=color:#f92672>.</span>fromString<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MONTH&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DateTimeUtils</span><span style=color:#f92672>.</span>truncDate<span style=color:#f92672>(</span>date<span style=color:#f92672>.</span>asInstanceOf<span style=color:#f92672>[</span><span style=color:#66d9ef>Int</span><span style=color:#f92672>],</span> level<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//  override protected def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    val level = DateTimeUtils.parseTruncLevel(UTF8String.fromString(&#34;MONTH&#34;))
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    val dtu   = DateTimeUtils.getClass.getName.stripSuffix(&#34;$&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    defineCodeGen(ctx, ev, sd =&gt; s&#34;$dtu.parseTruncLevel($sd, $level)&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> prettyName<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;beginning_of_month&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>The can be registered and used in spark as :</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Scala data-lang=Scala><span style=display:flex><span>  <span style=color:#66d9ef>def</span> main<span style=color:#f92672>(</span>args<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Array</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span><span style=color:#f92672>])</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>....</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Register the function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>BegRegister</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>NativeFunctionRegistration</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> expressions<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Map</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span>, <span style=color:#f92672>(</span><span style=color:#66d9ef>ExpressionInfo</span>, <span style=color:#66d9ef>FunctionBuilder</span><span style=color:#f92672>)]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Map</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>        expression<span style=color:#f92672>[</span><span style=color:#66d9ef>BeginningOfMonth</span><span style=color:#f92672>](</span><span style=color:#e6db74>&#34;beg_m&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>BegRegister</span><span style=color:#f92672>.</span>registerFunctions<span style=color:#f92672>(</span>spark<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>import</span> spark.implicits._
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> df <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Seq</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#a6e22e>Date</span><span style=color:#f92672>.</span>valueOf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;2020-01-15&#34;</span><span style=color:#f92672>)),</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#a6e22e>Date</span><span style=color:#f92672>.</span>valueOf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;2020-01-20&#34;</span><span style=color:#f92672>)),</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>).</span>toDF<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;some_date&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    df<span style=color:#f92672>.</span>show<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>    df<span style=color:#f92672>.</span>createTempView<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;dates&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> dfVal <span style=color:#66d9ef>=</span> spark<span style=color:#f92672>.</span>sql<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;SELECT beg_m(some_date) from dates&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    dfVal<span style=color:#f92672>.</span>show<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>In codegenfallback example CodegenFallback trait is used and doGenCode() method is not required as eval(or nullSafeEval).</li></ul><p>References :</p><ol><li><a href=https://databricks.com/blog/2015/04/13/deep-dive-into-spark-sqls-catalyst-optimizer.html>https://databricks.com/blog/2015/04/13/deep-dive-into-spark-sqls-catalyst-optimizer.html</a></li><li><a href=https://jaceklaskowski.gitbooks.io/mastering-spark-sql>https://jaceklaskowski.gitbooks.io/mastering-spark-sql</a></li></ol></section><div class=post-tags></div></article></main><footer><hr><a class=soc href=https://github.com/shivamanipatil title=GitHub><i data-feather=github></i></a>|<a class=soc href=https://twitter.com/ShivamaniPatil_ title=Twitter><i data-feather=twitter></i></a>|⚡️
2022 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></footer><script>feather.replace()</script></div></body></html>